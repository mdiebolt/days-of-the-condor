<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta content='IE=edge;chrome=1' http-equiv='X-UA-Compatible'>
    <link href="http://fonts.googleapis.com/css?family=Lato:300|Libre+Baskerville" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/blog.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <header m-fixed>
      <h1>
        <a href='/' m-no-underline>Days of the Condor</a>
      </h1>
      <div class='blog-information' m-top-right>
        <a class='blog-information--projects' href='https://github.com/mdiebolt'>Projects</a>
        <a class='blog-information--about' href='http://diebo.lt'>About</a>
        <div class='blog-information--recent-article-navigation'>
          <div class='blog-information--top-bar'></div>
          <div class='blog-information--middle-bar'></div>
          <div class='blog-information--bottom-bar'></div>
        </div>
      </div>
    </header>
    <div class='blog-page'>
      <div class='blog-page--container'>
        <div class='blog-page--post'>
          <h2 class='title'>
            <a href="/2012/12/16/coffeescript-static-analysis.html">CoffeeScript static analysis</a>
          </h2>
          <div class='blog-date' m-fixed='' m-left=''>
            <div class='blog-date--month'>DEC</div>
            <div class='blog-date--day' m-bold>16</div>
            <div class='blog-date--year'>2012</div>
          </div>
        </div>
        <p>For a while I&rsquo;ve been looking for code quality tools to analyze CoffeeScript. I haven&rsquo;t found anything very promising. So as part of a recent push to become more comfortable with Bash scripting, I decided I&rsquo;d cut some corners and do it myself.</p>
        
        <p>Here&rsquo;s a utility function I wrote to help me color text. It colors output yellow when it&rsquo;s within a warning range, and red when it exceeds a critical range.</p>
        <pre class="highlight shell"><code><span class="c">#!/usr/bin/env sh</span>&#x000A;&#x000A;<span class="c"># set the output color based on conditions</span>&#x000A;set_output_color<span class="o">()</span> <span class="o">{</span>&#x000A;  <span class="nb">local </span><span class="nv">value</span><span class="o">=</span><span class="nv">$1</span>&#x000A;  <span class="nb">local </span><span class="nv">medium_threshold</span><span class="o">=</span><span class="nv">$2</span>&#x000A;  <span class="nb">local </span><span class="nv">high_threshold</span><span class="o">=</span><span class="nv">$3</span>&#x000A;&#x000A;  <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$value</span><span class="s2">"</span> -gt <span class="s2">"</span><span class="nv">$high_threshold</span><span class="s2">"</span> <span class="o">]</span>&#x000A;  <span class="k">then&#x000A;    </span><span class="nb">echo</span> -en <span class="nv">$red</span>&#x000A;  <span class="k">elif</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$value</span><span class="s2">"</span> -gt <span class="s2">"</span><span class="nv">$medium_threshold</span><span class="s2">"</span> <span class="o">]</span>&#x000A;  <span class="k">then&#x000A;    </span><span class="nb">echo</span> -en <span class="nv">$yellow</span>&#x000A;  <span class="k">else&#x000A;    </span><span class="nb">echo</span> -en <span class="nv">$reset</span>&#x000A;  <span class="k">fi</span>&#x000A;<span class="o">}</span>&#x000A;</code></pre>
        
        <p>As I mentioned in my previous post about <a href="/2012/12/10/clean-bash-profiles.html">clean bash profiles</a>, I export the most common colors as variable so that I don&rsquo;t need to remember Bash escape sequences.</p>
        
        <p>In this function I use those color variables to set the output color based on two parameters, <code>medium_threshold</code> and <code>high_threshold</code>, which are passed into the function as positional parameters, making sure to reset the color if the value doesn&rsquo;t fall within the threshold range.</p>
        
        <p>Building on <code>set_output_color</code>, I put together a short function to count the lines of code in each file below the current directory.</p>
        
        <h4>Metric: Lines of code</h4>
        
        <p>Lines of code is perhaps the most basic metric. As your code evolves it&rsquo;s easy to keep implementing feature after feature in the same file, glossing over the fact that a class or module is too long and should be split into another file for ease of reading and code clarity.</p>
        <pre class="highlight shell"><code><span class="c">#!/usr/bin/env sh</span>&#x000A;&#x000A;<span class="c"># count lines of code in each file in the current directory</span>&#x000A;<span class="c"># report back long files</span>&#x000A;loc<span class="o">()</span> <span class="o">{</span>&#x000A;  <span class="nb">local </span><span class="nv">high</span><span class="o">=</span>200&#x000A;  <span class="nb">local </span><span class="nv">medium</span><span class="o">=</span>150&#x000A;&#x000A;  <span class="k">for </span>file <span class="k">in</span> <span class="sb">`</span>find . -type f<span class="sb">`</span>&#x000A;  <span class="k">do&#x000A;    </span><span class="nv">count</span><span class="o">=</span><span class="sb">`</span>cat <span class="nv">$file</span> | wc -l<span class="sb">`</span>&#x000A;&#x000A;    <span class="c"># set output color based</span>&#x000A;    <span class="c"># on thresholds passed in</span>&#x000A;    set_output_color <span class="nv">$count</span> <span class="nv">$medium</span> <span class="nv">$high</span>&#x000A;&#x000A;    <span class="nb">echo</span> <span class="sb">`</span>basename <span class="nv">$file</span><span class="sb">`</span> <span class="nv">$count</span>&#x000A;  <span class="k">done</span>&#x000A;<span class="o">}</span>&#x000A;</code></pre>
        
        <p>This returns a nice colored output, highlighting files longer than 150 lines in yellow, and files longer than 200 lines in red. The thresholds chosen are based on personal preference.</p>
        
        <h4>Metric: Cyclomatic complexity</h4>
        
        <p>This metric is a bit more tricky to calculate, but essentially boils down to the number of paths that exist through the code. A file with high complexity often includes messy conditional logic and is a good place to start refactoring.</p>
        <pre class="highlight shell"><code><span class="c">#!/usr/bin/env sh</span>&#x000A;&#x000A;<span class="c"># approximate cyclomatic complexity of files</span>&#x000A;<span class="c"># under the current directory</span>&#x000A;complexity<span class="o">()</span> <span class="o">{</span>&#x000A;  <span class="nb">local </span>file&#x000A;  <span class="nb">local </span>count&#x000A;&#x000A;  <span class="nb">local </span><span class="nv">high</span><span class="o">=</span>15&#x000A;  <span class="nb">local </span><span class="nv">medium</span><span class="o">=</span>10&#x000A;&#x000A;  <span class="c"># look through all files in and</span>&#x000A;  <span class="c"># below this directory recursively</span>&#x000A;  <span class="k">for </span>file <span class="k">in</span> <span class="sb">`</span>find . -type f<span class="sb">`</span>&#x000A;  <span class="k">do</span>&#x000A;    <span class="c"># count the number of</span>&#x000A;    <span class="c"># if statements plus one</span>&#x000A;    <span class="nv">count</span><span class="o">=</span><span class="sb">`</span>cat <span class="nv">$file</span> | grep <span class="s1">'if '</span> | wc -l<span class="sb">`</span>&#x000A;    <span class="nv">count</span><span class="o">=</span><span class="k">$((</span><span class="nv">$count</span> <span class="o">+</span> <span class="m">1</span><span class="k">))</span>&#x000A;&#x000A;    set_output_color <span class="nv">$count</span> <span class="nv">$medium</span> <span class="nv">$high</span>&#x000A;&#x000A;    <span class="nb">echo</span> <span class="sb">`</span>basename <span class="nv">$file</span><span class="sb">`</span> <span class="nv">$count</span> <span class="nv">$line_output</span>&#x000A;  <span class="k">done</span>&#x000A;<span class="o">}</span>&#x000A;</code></pre>
        
        <p>Although this is a very crude approximation of cyclomatic complexity, I&rsquo;ve found it to be useful in pointing out files that could use refactoring.</p>
        
        <p>The function is very simple. It iterates over all files below the current directory and counts the number of lines containing an <code>if</code> statement, then adds one to that number, since there is always one path through your code before any conditionals are added. A more complete and accurate tool would add weight to nested <code>if</code> statements and would include iterators / for loops in the count.</p>
        
        <p>The thresholds were chosen based on complexity values discussed in the <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity">wikipedia article about cyclomatic complexity</a>.</p>
        
        <h4>Metric: Lines of code per method</h4>
        
        <p>Long methods are hard to follow and should almost always be broken up into smaller methods with clear names that describe what they do.</p>
        <pre class="highlight ruby"><code><span class="c1">#!/usr/bin/env ruby</span>&#x000A;&#x000A;<span class="k">def</span> <span class="nf">contains_function?</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>&#x000A;  <span class="o">!</span><span class="p">(</span><span class="n">line</span> <span class="o">=~</span> <span class="sr">/-&gt;|=&gt;/</span><span class="p">).</span><span class="nf">nil?</span>&#x000A;<span class="k">end</span>&#x000A;&#x000A;<span class="c1"># TODO this doesn't catch functions created like this</span>&#x000A;<span class="c1"># someFn = =&gt; "blah" or someFn = (arg) =&gt; 'blah'</span>&#x000A;<span class="k">def</span> <span class="nf">function_name</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>&#x000A;  <span class="k">if</span> <span class="n">index</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="s2">":"</span><span class="p">)</span>&#x000A;    <span class="n">line</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">).</span><span class="nf">strip!</span>&#x000A;  <span class="k">end</span>&#x000A;<span class="k">end</span>&#x000A;&#x000A;<span class="k">def</span> <span class="nf">method_length</span><span class="p">(</span><span class="n">line_number</span><span class="p">,</span> <span class="n">function_start</span><span class="p">)</span>&#x000A;  <span class="n">line_number</span> <span class="o">-</span> <span class="n">function_start</span> <span class="o">-</span> <span class="mi">2</span>&#x000A;<span class="k">end</span>&#x000A;&#x000A;<span class="k">def</span> <span class="nf">report</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">line_number</span><span class="p">,</span> <span class="n">function_start</span><span class="p">)</span>&#x000A;  <span class="s2">"</span><span class="si">#{</span><span class="n">method_length</span><span class="p">(</span><span class="n">line_number</span><span class="p">,</span> <span class="n">function_start</span><span class="p">)</span><span class="si">}</span><span class="s2"> lines - </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>&#x000A;<span class="k">end</span>&#x000A;&#x000A;<span class="k">def</span> <span class="nf">function_line_count</span>&#x000A;  <span class="n">file</span> <span class="o">=</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">first</span>&#x000A;&#x000A;  <span class="nb">name</span> <span class="o">=</span> <span class="kp">nil</span>&#x000A;  <span class="n">function_start</span> <span class="o">=</span> <span class="mi">0</span>&#x000A;&#x000A;  <span class="c1"># TODO nested functions will break this</span>&#x000A;  <span class="no">File</span><span class="p">.</span><span class="nf">open</span> <span class="n">file</span><span class="p">,</span> <span class="s1">'r'</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span>&#x000A;    <span class="k">while</span> <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">gets</span>&#x000A;      <span class="c1"># if there is a function declaration on this line</span>&#x000A;      <span class="k">if</span> <span class="n">contains_function?</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">function_name</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>&#x000A;        <span class="c1"># if we've found a new function then report on the last one</span>&#x000A;        <span class="nb">puts</span> <span class="n">report</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="nf">lineno</span><span class="p">,</span> <span class="n">function_start</span><span class="p">)</span> <span class="k">if</span> <span class="nb">name</span>&#x000A;&#x000A;        <span class="c1"># set where this functions starts and its name</span>&#x000A;        <span class="n">function_start</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">lineno</span>&#x000A;        <span class="nb">name</span> <span class="o">=</span> <span class="n">function_name</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>&#x000A;      <span class="k">end</span>&#x000A;    <span class="k">end</span>&#x000A;&#x000A;    <span class="c1"># add 2 because the blank line at the end of the file</span>&#x000A;    <span class="nb">puts</span> <span class="n">report</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="nf">lineno</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">function_start</span><span class="p">)</span>&#x000A;  <span class="k">end</span>&#x000A;<span class="k">end</span>&#x000A;&#x000A;<span class="c1"># execute the function if we are</span>&#x000A;<span class="c1"># executing the file by itself</span>&#x000A;<span class="k">if</span> <span class="kp">__FILE__</span> <span class="o">==</span> <span class="vg">$0</span>&#x000A;  <span class="n">function_line_count</span>&#x000A;<span class="k">end</span>&#x000A;</code></pre>
        
        <p>This last script is written in Ruby because I couldn&rsquo;t figure out a good way to write it in Bash. It counts the number of lines in each method. This is also the script that cheats the most, relying on a rigid structure to be accurate.</p>
        
        <p>It assumes you&rsquo;re working with a Backbone class in CoffeeScript, and detects methods based on the presence of <code>-&gt;</code> or <code>=&gt;</code>. After finding one of these identifiers, it stores the name of the function, determining that based on where it finds the <code>:</code> character (again, cheating by assuming an object literal style function declaration). Eg.</p>
        <pre class="highlight coffeescript"><code><span class="na">method1</span><span class="o">:</span> <span class="o">-&gt;</span>&#x000A;  <span class="nx">something</span><span class="p">()</span>&#x000A;&#x000A;<span class="na">method2</span><span class="o">:</span> <span class="o">=&gt;</span>&#x000A;  <span class="vi">@</span><span class="na">another</span><span class="p">()</span>&#x000A;</code></pre>
        
        <p>Once a function is found, the line number where it starts is stored. The script keeps going through the file until a new function is found. When this happens, the current line number is used against the start line of the previous function to determine the line count. A formatted description of the method is displayed on STDOUT.</p>
        
        <h4>What&rsquo;s next?</h4>
        
        <p>My plans for the future are to incorporate this complexity suite into a CI workflow, failing the build if code complexity reaches a certain point. I&rsquo;ll probably want to modify it to exclude third party code.</p>
        
        <p>Although this test suite is by no means rigorous in a computer science sense, it provides good insight into the quality of my code with minimal effort spent to develop it.</p>
      </div>
    </div>
    <nav class='blog-previous-posts' m-fixed-right>
      <div class='blog-previous-posts--container'>
        <img class="blog-logo" src="/images/logo.svg" />
        <h2 class='blog-previous-posts--title'>Recent Articles</h2>
        <ul class='blog-previous-posts--list'>
          <li class='blog-previous-posts--article'>
            <a href='/2012/12/16/coffeescript-static-analysis.html'>CoffeeScript static analysis</a>
            <div class='date'>Dec 16, 2012</div>
          </li>
          <li class='blog-previous-posts--article'>
            <a href='/2012/12/10/clean-bash-profiles.html'>Clean bash profiles</a>
            <div class='date'>Dec 10, 2012</div>
          </li>
          <li class='blog-previous-posts--article'>
            <a href='/2011/10/05/Programmatically focus content inside an iFrame.html'>Programmatically focus content inside an iFrame</a>
            <div class='date'>Oct  5, 2011</div>
          </li>
          <li class='blog-previous-posts--article'>
            <a href='/2011/09/20/jQuery-UI-Draggable-stop-drag-programmatically.html'>jQuery UI Draggable stop drag programmatically</a>
            <div class='date'>Sep 20, 2011</div>
          </li>
          <li class='blog-previous-posts--article'>
            <a href='/2011/09/15/Arrays-and-jQuery-data-attributes.html'>Arrays and jQuery data attributes</a>
            <div class='date'>Sep 15, 2011</div>
          </li>
          <li class='blog-previous-posts--article'>
            <a href='/2011/03/17/OS-X-dock-in-css.html'>OS X dock in css</a>
            <div class='date'>Mar 17, 2011</div>
          </li>
          <li class='blog-previous-posts--article'>
            <a href='/2011/03/14/glass.sass.html'>glass.sass</a>
            <div class='date'>Mar 14, 2011</div>
          </li>
          <li class='blog-previous-posts--article'>
            <a href='/2010/12/08/Snake-html.html'>Snake</a>
            <div class='date'>Dec  8, 2010</div>
          </li>
          <li class='blog-previous-posts--article'>
            <a href='/2010/10/11/Contrasaurus-launched.html'>Contrasaurus launched</a>
            <div class='date'>Oct 11, 2010</div>
          </li>
          <li class='blog-previous-posts--article'>
            <a href='/2010/08/31/Contrasaurus.html'>Contrasaurus</a>
            <div class='date'>Aug 31, 2010</div>
          </li>
        </ul>
      </div>
    </nav>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-20149612-1', 'auto');
      ga('send', 'pageview');
    </script>
    <script>
      var nav = document.querySelector(".blog-information--recent-article-navigation")
      nav.addEventListener("click", function() {
        if (document.body.hasAttribute("s-slide-out")) {
          document.body.removeAttribute("s-slide-out")
        } else {
          document.body.setAttribute("s-slide-out", "")
        }
      })
      
      window.addEventListener("resize", function() {
        if (window.innerWidth > 640) {
          document.body.removeAttribute("s-slide-out")
        }
      })
    </script>
  </body>
</html>
